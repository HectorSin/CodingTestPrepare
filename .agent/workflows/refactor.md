---
description: 백준 문제 코드 리팩토링 및 피드백 (Baekjoon Refactoring)
---

## 백준 문제 코드 분석 및 학습 가이드

### 1. **현재 작업 중인 파일 확인**
   - 사용자가 현재 열어놓은 파일(Active Document)을 읽습니다.

### 2. **문제 링크 파악**
   - 파일 내용(주석 등)에서 백준 문제 링크(예: `acmicpc.net/problem/XXXX`)를 찾습니다.
   - 링크가 없다면 사용자에게 "문제 번호나 링크를 알려주세요"라고 요청하거나, 일반적인 코드 최적화 관점에서 분석을 진행합니다.

### 3. **문제 분석 (링크 확인 시)**
   - `browser_subagent`를 사용하여 해당 문제 링크로 이동합니다.
   - 다음 정보들을 파악합니다:
     - **문제 개요**: 무엇을 구하는 문제인가?
     - **입력 조건**: N의 최대 크기, 입력 형식 (시간 복잡도 제약 파악용)
     - **출력 조건**: 정답 포맷
     - **제한 시간/메모리**: 성능 최적화 기준

### 4. **코드 분석**
   - 현재 코드가 문제의 요구사항을 만족하는지 확인합니다.
   - **시간 복잡도 분석**: 입력 크기(N) 대비 현재 알고리즘이 제한 시간 내에 통과 가능한지 계산합니다.
   - **공간 복잡도 분석**: 메모리 초과 가능성을 점검합니다.
   - **엣지 케이스**: 놓치기 쉬운 예외 상황을 확인합니다.

### 5. **학습 중심 피드백 (힌트 제공)**
   - **중요**: 직접적인 코드 수정이나 정답을 제공하지 않고, 사용자가 스스로 해결할 수 있도록 **단계적 힌트**를 제공합니다.
   - **파일 상단 주석**:

"""
# 문제 분석: [간단한 문제 요약]
# 현재 접근: [사용자 코드의 접근 방식]
# 힌트 레벨 1: [방향성만 제시]
"""

- **문제 지점 주석**:
```python
     # 💡 힌트: 이 부분의 시간 복잡도를 다시 계산해보세요
     # 🤔 생각해보기: N이 100,000일 때 이 반복문은 몇 번 실행될까요?
     # 📌 체크포인트: 이 조건에서 놓친 케이스가 있을 수 있습니다
```

### 6. **단계별 힌트 제공 전략**
   - **Level 1 (방향성)**: "현재 O(N²) 알고리즘인데, 더 효율적인 방법이 있을 것 같네요"
   - **Level 2 (접근법)**: "정렬을 먼저 하면 어떨까요?" (사용자가 막힐 때만)
   - **Level 3 (구체적 기법)**: "투 포인터를 고려해보세요" (여전히 막힐 때만)
   - **Level 4 (의사코드)**: 최후의 수단으로만 제공

### 7. **결과 보고**
   - "코드를 분석했고, 학습에 도움이 될 힌트를 주석으로 남겼습니다."
   - "우선 Level 1 힌트부터 확인해보시고, 필요하면 더 구체적인 힌트를 요청해주세요."
   - 문제 해결 성공 시:
     - 간단한 축하 메시지
     - 개선 가능성이 있다면: "잘 해결하셨네요! 혹시 더 효율적인 방법이 궁금하시면 말씀해주세요."
     - 추가 질문이 없으면 자세한 설명은 생략

### 8. **교육적 원칙**
   - 사용자가 직접 문제를 해결하는 성취감을 느끼도록 합니다.
   - 실패도 학습의 일부임을 인정하고, 너무 빨리 답을 제공하지 않습니다.
   - "틀렸다"보다는 "다른 접근을 시도해보면 어떨까요?"로 표현합니다.
   - 사용자가 명시적으로 "답을 알려줘" 또는 "수정해줘"라고 하지 않는 한 직접적인 해답은 제공하지 않습니다.