# 큰수의 법칙 문제
#
# [문제 설명]
# 다양한 수로 이루어진 배열이 있을 때 주어진 수들을 M번 더하여 가장 큰 수를 만드는 법칙
#
# [제약 조건]
# 1. 배열의 특정한 인덱스에 해당하는 수가 연속해서 K번을 초과하여 더해질 수 없음
# 2. 서로 다른 인덱스에 해당하는 수가 같은 경우에는 서로 다른 것으로 간주
#
# [입력 형식]
# - 첫째 줄: N(배열의 크기), M(더하는 횟수), K(연속 허용 횟수)
# - 둘째 줄: N개의 자연수(공백으로 구분)
#
# [예시]
# 입력: 5 8 3
#       2 4 5 4 6
# 출력: 46
# 설명: 가장 큰 수 6을 3번, 두번째로 큰 수 5를 1번 더하는 패턴을 반복
#       (6+6+6+5) + (6+6+6+5) = 46
#
# [해결 전략]
# 1. 배열을 오름차순으로 정렬
# 2. 가장 큰 수(first)를 K번 더하고, 두번째로 큰 수(second)를 1번 더하는 패턴 반복
# 3. M번 모두 더할 때까지 반복

# 입력 받기
N, M, K = map(int,input().split())

# [주의] map 객체를 list로 변환해야 sort() 메서드 사용 가능
# map(int, input().split())은 map 객체를 반환하므로 list()로 감싸지 않으면
# AttributeError: 'map' object has no attribute 'sort' 에러 발생
data = list(map(int,input().split()))

# 오름차순 정렬하여 가장 큰 수와 두번째로 큰 수를 찾기 위함
data.sort()

# 가장 큰 수: 배열의 마지막 요소
first_num = data[-1]
# 두번째로 큰 수: 배열의 마지막에서 두번째 요소
second_num = data[-2]

result = 0

# 그리디 알고리즘: 가장 큰 수를 K번 더하고, 두번째 큰 수를 1번 더하는 패턴 반복
while True:
    # 가장 큰 수를 K번 연속으로 더하기
    for i in range(K):
        if M == 0:  # M번 모두 더했으면 종료
            break
        result += first_num
        M -= 1  # 남은 더하기 횟수 감소

    if M == 0:  # M번 모두 더했으면 반복문 종료
        break

    # 두번째로 큰 수를 1번 더하기 (연속 K번 제한을 초기화하기 위함)
    result += second_num
    M -= 1

print(result)