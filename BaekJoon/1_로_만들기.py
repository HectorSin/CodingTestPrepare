"""
# 1. 버그 수정 제안: 아래 식에서 `n%3`, `n%2`를 사용하고 있습니다.
#    반복문 변수 `i`에 대한 계산이므로 `i%3`, `i%2`로 바꿔야 합니다!
#    이유: 현재 숫자 `i`를 1로 만드는 비용을 계산하는 중이기 때문입니다.
#
# 2. 로직 검증: `hash_table[i//3] + 1 + i%3`
#    - 이 식은 "3의 배수가 될 때까지 1을 빼고(i%3회), 3으로 나누는(1회) 비용"을 의미합니다.
#    - 아주 훌륭한 접근입니다! 보통 `if i%3==0`으로 분기하는데, 이 식은 일반화된 형태입니다.
#    - 다만, 변수만 `i`로 고쳐주면 완벽합니다.
"""
n = int(input())

# 💡 깔끔한 초기화:
# 사실 for문을 2부터 돌리면 2, 3은 루프 안에서 자동 처리되어 if-elif-else 초기화가 없어도 됩니다.
# (dp[0]=0, dp[1]=0 초기값만 있으면 됨)
hash_table = [0] * (n+1)

for i in range(2,n+1):
    hash_table[i] = min(hash_table[i-1] + 1, hash_table[i//3] + 1 + i%3, hash_table[i//2] + 1 + i%2)

print(hash_table[n])

"""
# 추가 팁 (Python 성능 최적화):
# - 10^6 범위에서는 for loop가 다소 느릴 수 있습니다.
# - Python에서는 `top-down` (재귀 + 메모이제이션) 방식이 필요한 상태만 방문하므로
#   경우에 따라 더 빠를 수 있습니다. (딕셔너리 사용 추천)
#   예: solution(n) = min(solution(n//3) + n%3 + 1, ...)
# - 하지만 이 문제는 Bottom-up으로도 통과 가능합니다. 위 로직(`i//3 + i%3 + 1`)은 아주 좋은 접근입니다. 버그만 잡으세요!
"""