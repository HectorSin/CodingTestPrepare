# 1s, 512mb
# 문제 분석: 정수 n을 1, 2, 3의 합으로 나타내는 방법의 수를 구하는 문제입니다. n < 11로 입력이 매우 작습니다.
# 현재 접근: 2와 3의 개수를 정하고, 나머지 1의 개수를 계산한 뒤 다항 계수(순열) 공식을 이용해 경우의 수를 합산하고 있습니다.
# 힌트 레벨 1: n이 작아서 이 수학적 접근도 충분히 통과합니다. 하지만 n이 커진다면 DP(동적 계획법)가 더 효율적일 수 있습니다.
# 힌트 레벨 2: 점화식을 찾아보세요. f(n)을 구하기 위해 f(n-1), f(n-2), f(n-3)과의 관계를 생각해보면 어떨까요?
#
# Q: 왜 시간/메모리 차이가 없나요?
# A: 입력값 N이 최대 10으로 매우 작아서 그렇습니다.
#    만약 N이 100이었다면 기존 방식(순열 계산)은 계산량이 급증하거나 숫자가 너무 커져 느려졌겠지만,
#    DP 방식은 여전히 0.0001초 안에 끝납니다. "확장성"에서 큰 차이가 있습니다.





T = int(input())

pb_table = [0] * 11

pb_table[1] = 1
pb_table[2] = 2
pb_table[3] = 4

for _ in range(T):
    case = int(input()) # 11보다 작음

    # 이미 계산된 값은 다시 계산하지 않음 (Memoization)
    for i in range(4, case+1):
        if pb_table[i] == 0:
            pb_table[i] = pb_table[i-3] + pb_table[i-2] + pb_table[i-1]

    print(pb_table[case])