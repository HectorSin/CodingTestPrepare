# 문제 분석: 백준 1676 - 팩토리얼 0의 개수
# 링크: https://www.acmicpc.net/problem/1676
#
# 문제: N!의 뒤에서부터 이어지는 0의 개수 구하기
#
# [알고리즘 설명: 르장드르 공식 (Legendre's Formula)]
# 1. 0의 개수는 소인수 10(2*5)의 개수와 같습니다.
# 2. 팩토리얼에서는 항상 2의 개수가 5의 개수보다 많으므로, '5의 개수'만 세면 됩니다.
# 3. 1부터 N까지의 곱(N!)에 포함된 소인수 5의 총 개수는
#    (N // 5) + (N // 25) + (N // 125) ... 로 구할 수 있습니다.
#    - N // 5 : 5의 배수(5, 10, 15...)마다 5가 최소 1개 있습니다.
#    - N // 25: 25의 배수(25, 50...)에는 5가 하나 더 들어있습니다. (5*5 이므로)
#    - N // 125: 5가 3개인 수들입니다.
#
# 이 방식은 팩토리얼을 직접 계산하지 않아도 되므로 O(log N)으로 매우 빠릅니다.

import sys

# 입력
N = int(sys.stdin.readline())

# ==c= [방법 1] 최적화된 방법 (추천) ===
count = 0

while N >= 5:
    count += N // 5
    N //= 5

print(count)

# === [방법 2] 기존 방식 (참고용) ===
# 팩토리얼을 직접 계산하고 0을 세는 방식은 N이 작을 때 직관적이지만,
# N이 커지면(예: N=10000) 연산량이 많아집니다.
'''
number = 1
counter = 0

# 팩토리얼 계산
for i in range(N):
    number = number * (i + 1)
    # 곱하는 도중에도 10으로 나누어떨어지면 카운트 및 나누기 (숫자가 너무 커지는 것 방지)
    while number % 10 == 0:
        number //= 10
        counter += 1

print(counter)
'''
